
```{r}
library(data.table)
library(Matrix)
library(gurobi)
library(readxl)
library(stringr)
library(mltools)
library(ggplot2)
library(geosphere)
```

```{r}
knitr::opts_knit$set(root.dir = normalizePath("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/"))
```

```{r}
# To calculate s/d ratio for homogeneous 500NM radius circles:
fixed_rad = 0
```


```{r}
# First three digit Zip code: http://www.trucksess.com/maps/zcta/9.php#wa
getwd()
```

Zip_cluster Demand is as per MELD >= 15, like DSA models MELD >= 15!!!
```{r}
df_dem = read.csv("Files_JHU/zip_transplant.csv", stringsAsFactors = FALSE)    # Demand data at the level of transplant centres
#df_dem = df_dem[, c(1,6,16)]
df_dem$dem = df_dem[, c("MELD.15_2013")] + df_dem[, c("MELD.15_2014")] + df_dem[, c("MELD.15_2015")] + df_dem[, c("MELD.15_2016")]  # 2013, 2014, 2015 & 2016.
# temp = as.data.frame(unique(df_dem$OPO))
```

```{r}
# Enter Zip-cluster: Either "2" or "3":
zip_cluster =  "4" #readline("What is the value of x?")
```

```{r}
distance_matrix_Zip5 = function() {
  
  # For Zips found in master2 file:
  no_zips_in_dist_matrix = setdiff(df_sup$zip_cluster, df_donor_trnspl_dist$X__1)
  
  # Lat/lon of TCs:
  txc = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/Files_JHU/zip_transplant.csv")
  txc = txc[, c("transplant_center","INTPTLAT10","INTPTLON10")]
  txc_geo_lst = as.matrix(txc[, c(3, 2)])
  
  # Lat/lon of Zips not found in the master shape file:
  dff = data.frame(Zip_cluster = no_zips_in_dist_matrix)
  
  master2 = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/Files_JHU/Shubham_downloads/us-zip-code-latitude-and-longitude.csv")
  dff = merge(dff, master2[, c("Zip_cluster", "Longitude", "Latitude")])
  
  dff_out = data.frame(distm(as.matrix(dff[, c("Longitude", "Latitude")]), txc_geo_lst, distVincentyEllipsoid) / 1000)    # Longitute-Latitude  # Unit: Kms
  colnames(dff_out) = txc[, 1]
  dff_out = cbind(dff[, 1], dff_out)
  colnames(dff_out)[1] = c("X__1")
  
  # Merge to "df_donor_trnspl_dist":
  df_donor_trnspl_dist = rbind(df_donor_trnspl_dist, dff_out)
  
  # Because some Zipcodes (with supply) were not found in the master shape file "tl_2018_us_zcta510" (see Distance_matrix.R for details), these Zipcodes are assigned the LATITUDE/LONGITUDE of nearby Zipcodes that are there in the shape file! 
  Zip_lst_num = as.numeric(str_sub(df_donor_trnspl_dist$X__1, 3))
  
  no_zips_in_dist_matrix = setdiff(df_sup$zip_cluster, df_donor_trnspl_dist$X__1)
  
  new_df = data.frame(matrix(nrow = length(no_zips_in_dist_matrix), ncol = 1 + ncol(df_donor_trnspl_dist)))
  colnames(new_df) = c("Proxy_Zip", colnames(df_donor_trnspl_dist))
  
  k = 1
  for (zip in no_zips_in_dist_matrix) {
    zip_c = as.numeric(str_sub(zip, 3))
    zip_delta = 1
    flag = 0
    while (flag == 0) {     # Looking for Zipcodes that are nearest in 'value' to the "zip_c" 
      new_zip_c1 = zip_c + zip_delta
      new_zip_c2 = zip_c - zip_delta
      if (new_zip_c1 %in% Zip_lst_num) {
        row = which(Zip_lst_num == new_zip_c1)
        new_df[k, ] = c(new_zip_c1, as.character(zip), as.numeric(as.character(df_donor_trnspl_dist[row, -1])))
        flag = 1; 
        print (paste(zip_delta, zip, df_donor_trnspl_dist[row, 1]))
        k = k + 1
      } else if (new_zip_c2 %in% Zip_lst_num) {
        row = which(Zip_lst_num == new_zip_c2)
        new_df[k, ] = c(new_zip_c2, as.character(zip), as.numeric(as.character(df_donor_trnspl_dist[row, -1])))
        flag = 1; 
        print (paste(zip_delta, zip, df_donor_trnspl_dist[row, 1]))
        k = k + 1
      }
      zip_delta = zip_delta + 1
    }
  }
  df_donor_trnspl_dist = rbind(df_donor_trnspl_dist, new_df[-1])
  return(df_donor_trnspl_dist)
}
```

```{r}
distance_matrix_Zip4 = function() {
  # For Zips found in master2 file:
  no_zips_in_dist_matrix = setdiff(df_sup$zip_cluster, df_donor_trnspl_dist$X__1)
  
  # Lat/lon of TCs:
  txc = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/Files_JHU/zip_transplant.csv")
  txc = txc[, c("transplant_center","INTPTLAT10","INTPTLON10")]
  txc_geo_lst = as.matrix(txc[, c(3, 2)])
  
  # Lat/lon of Zips not found in the master shape file:
  dff = data.frame(Zip_cluster = no_zips_in_dist_matrix)
  
  master2 = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/Files_JHU/Shubham_downloads/us-zip-code-latitude-and-longitude.csv")
  colnames(master2)[1] = "Zip_cluster"
  master2$Zip_cluster_4dgt = substr(master2$Zip_cluster, 1, 6)
  master2$Zip_cluster = master2$Zip_cluster_4dgt
  master2_centroid = data.frame(data.table(master2)[, list(Longitude = mean(Longitude), Latitude = mean(Latitude)), by = Zip_cluster])
  dff = merge(dff, master2_centroid[, c("Zip_cluster", "Longitude", "Latitude")], all.x = T)
  
  dff_out = data.frame(distm(as.matrix(dff[, c("Longitude", "Latitude")]), txc_geo_lst, distVincentyEllipsoid) / 1000)    # Longitute-Latitude  # Unit: Kms
  colnames(dff_out) = txc[, 1]
  dff_out = cbind(dff[, 1], dff_out)
  colnames(dff_out)[1] = c("X__1")
  
  # Merge to "df_donor_trnspl_dist":
  df_donor_trnspl_dist = rbind(df_donor_trnspl_dist, dff_out)
  
  return(df_donor_trnspl_dist)
}
```

```{r}
if (zip_cluster == "2") {
  # file_name = "two_digit.xlsx"
  df_sup = read.csv('Files_JHU/Shubham_downloads/supply_2_digit.csv')
  df_donor_trnspl_dist = read.csv('Files_JHU/Shubham_downloads/dist_matrix_2_dgt.csv')
  df_donor_trnspl_dist = df_donor_trnspl_dist[df_donor_trnspl_dist[, 1] %in% df_sup[, 1], ]
  
} else if (zip_cluster == "3") {
  # file_name = "three_digit_dummy.xlsx"
  df_sup = read.csv('Files_JHU/Shubham_downloads/supply_3_digit.csv')
  df_donor_trnspl_dist = read.csv('Files_JHU/Shubham_downloads/dist_matrix_3_dgt.csv')
  df_donor_trnspl_dist = df_donor_trnspl_dist[df_donor_trnspl_dist[, 1] %in% df_sup[, 1], ]
  
} else if (zip_cluster == "4") {
  df_sup = read.csv('Files_JHU/Shubham_downloads/supply_4_digit.csv')
  df_donor_trnspl_dist = read.csv('Files_JHU/Shubham_downloads/dist_matrix_4_dgt.csv')
  df_donor_trnspl_dist = distance_matrix_Zip4()
  df_donor_trnspl_dist = df_donor_trnspl_dist[df_donor_trnspl_dist[, 1] %in% df_sup[, 1], ]
  
} else if (zip_cluster == "5") {
  df_sup = read.csv('Files_JHU/Shubham_downloads/supply_5_digit.csv')
  df_donor_trnspl_dist = read.csv('Files_JHU/Shubham_downloads/dist_matrix_5_dgt.csv')
  df_donor_trnspl_dist = distance_matrix_Zip5()
  df_donor_trnspl_dist = df_donor_trnspl_dist[df_donor_trnspl_dist[, 1] %in% df_sup[, 1], ]
}


# Delete 'Puerto Rico' row (C_00):

df_sup = df_sup[-grep("C_00", df_sup[, 1]), ]
df_sup$sup = df_sup[, c("donor_2013")] + df_sup[, c("donor_2014")] + df_sup[, c("donor_2015")] + df_sup[, c("donor_2016")]   # 2013, 2014, 2015 & 2016. 
df_sup = df_sup[df_sup$sup > 0, ]
#df_sup$sup = df_sup[, 7] + df_sup[, 8] + df_sup[, 9] + df_sup[, 10]   # 2014, 2015, 2016 & 2017. 

df_donor_trnspl_dist = df_donor_trnspl_dist[df_donor_trnspl_dist[, 1] %in% df_sup[, 1], ]
row.names(df_sup) = c(1:nrow(df_sup))
print (sum(df_sup$sup))
```

# To shift ALASKA Zips to SEA (-122.30602, 47.45052):
```{r}
library(geosphere)

# Zip_codes of transplant centres:
txc = df_dem[, c("transplant_center","INTPTLAT10","INTPTLON10")]
mat = as.matrix(txc[, c('INTPTLON10', 'INTPTLAT10')])

lst = distm(mat, t(c(-122.30602, 47.45052)), distVincentyEllipsoid) / 1000    # Longitute-Latitude  # Unit: Kms

# Check if cols to txc is same as df_donor_trnspl_dist:
identical(df_dem$transplant_center, colnames(df_donor_trnspl_dist)[-1])

# Zip clusters of Alaska:
alaska = read.csv("Files_JHU/Alaska_Zips.csv")

if(zip_cluster == "3") {
  alaska_zip_clusters = as.character(unique(alaska$Zip_3))
} else if (zip_cluster == "4") {
  alaska_zip_clusters = as.character(unique(alaska$Zip_4))
}
df_donor_trnspl_dist$X__1 = as.character(df_donor_trnspl_dist$X__1)
for (i in alaska_zip_clusters) {
  df_donor_trnspl_dist[which(df_donor_trnspl_dist$X__1 == i), -1] = lst
}
# temp = t(df_donor_trnspl_dist[df_donor_trnspl_dist$X__1 == "C_9950", -1])
```

Analysis of "Donor - Transplant centre" distances:
```{r}
transplant_centres = df_dem[, 1]
  
# Number of Donors (Zip-clusters) to a transplant centre within "ub_d" miles:

max_rad = 500 # In nautical miles

ub_d = max_rad  * 1.609 * 1.15078
temp = data.frame(transplant_centres, cnt_donors = NA)
temp$cnt_donors = sapply(transplant_centres, function(x) {sum(df_donor_trnspl_dist[, x] < ub_d)})

# Number of transplant centres to a Donor (Zip-cluster) within "ub_d" miles:

temp2 = data.frame(df_donor_trnspl_dist[, 1], cnt_t_centres = NA)
temp2$cnt_t_centres = sapply(c(1:nrow(df_donor_trnspl_dist)), function(x) {sum(df_donor_trnspl_dist[x, -1] < ub_d)})
```

```{r}
# Remove 'donors' who donot have any centre within 'ub_d':
donor_no_neigh = temp2[which(temp2[, 2] == 0), 1]

print (as.character(donor_no_neigh))
discarded_donors_supply = sum(df_sup[c(which(df_sup[, 1] %in% donor_no_neigh)), c("sup")])
print (paste("Supply @ Zip_clusters", length(donor_no_neigh), "with far off Txc: ", discarded_donors_supply))

if (length(donor_no_neigh) > 0) {
  df_sup = df_sup[-c(which(df_sup[, 1] %in% donor_no_neigh)), ]
  df_donor_trnspl_dist = df_donor_trnspl_dist[-c(which(unlist(df_donor_trnspl_dist[, 1]) %in% donor_no_neigh)), ]
}

# Remove 'centres' who have 0 or very few donors within 'ub_d':
centre_few_neigh = temp[which(temp[, 2] < 1), 1]
if (length(centre_few_neigh) > 0) {
  df_dem = df_dem[-c(which(df_dem[, 1] %in% centre_few_neigh)), ]
  df_donor_trnspl_dist = df_donor_trnspl_dist[, -which(names(df_donor_trnspl_dist) %in% centre_few_neigh)]
}

```

# Calculate the organ share as a function of distance:
```{r}
Sys.time()

# First
df_rad = data.frame(matrix(ncol = nrow(df_dem) + 1))
colnames(df_rad) = c('donor_rad', df_dem[, 1])

min_rad = 150 # In nautical miles
# max_rad =  # In nautical miles

max_rad_ = max_rad
k = 1     # Denotes row number in df_rad
for (donor in df_sup$zip_cluster) {

  temp = as.data.frame(t(df_donor_trnspl_dist[as.character(df_donor_trnspl_dist[, 1]) == as.character(donor), ])[-1, ])
  temp[, 1] = as.numeric(as.character(temp[, 1]))
  temp[, 2] = row.names(temp)
  
     ## EXCEPTIONS are C_980, 981, 983, 984, 985, 989, otherise lambda goes BELOW 0.53 with max_rad=600NM:
  # if ((zip_cluster == "3") & (max_rad > 500)) {
  #   if (donor %in% c("C_980", "C_981", "C_983", "C_984", "C_985", "C_989")) {
  #     max_rad_ = 500
  #   } else {
  #     max_rad_ = max_rad
  #   }
  # }
  # 
  # if ((zip_cluster == "4") & (max_rad > 550)) {
  #   if (donor %in% c("C_9800", "C_9802", "C_9803", "C_9805", "C_9810", "C_9811", "C_9812", "C_9813", "C_9816", "C_9819", "C_9820", "C_9831", "C_9833", "C_9836", "C_9837", "C_9840", "C_9841", "C_9843", "C_9849", "C_9850")) {
  #     max_rad_ = 550
  #   } else {
  #     max_rad_ = max_rad
  #   }
  # }
  
  # print (paste(donor, max_rad_))
  temp = temp[temp[, 1] <= max_rad_ * 1.609 * 1.15078, ]   # Centers <= max_rad_
  
  rad_lst = sort(unique(ceiling(temp[, 1]) + 1)) # Different for each donor!  
  #print (rad_lst)
  
  # Impose "minimum radius" AND "minimum TC = 3" constraints: 
  if (nrow(temp) < 3) {
    print (paste0(donor, ": # TCs is < 3 (within MAX_RAD)!: ", nrow(temp)))
  }
  
  if (max(rad_lst) > min_rad * 1.609 * 1.15078) {
    
    cond = (zip_cluster == "4") & (max_rad == 600) & (donor %in% c("C_9951"))    # Exception for 1 4_dgt cluster: "C_9951"
    if (cond) {
      rad_lst = rad_lst[rad_lst >= 221]
    } else if ((zip_cluster == "3") & (max_rad == 600) & (donor %in% c("C_981"))) {   # Exception for 1 3_dgt clusters
      rad_lst = rad_lst[rad_lst >= 168]
    }
    else {
      rad_lst = rad_lst[rad_lst >= min_rad * 1.609 * 1.15078]
    }
    if(fixed_rad == 1) {rad_lst = rad_lst[length(rad_lst)]}
  } else {
    # Retain only the maximum radius!, 
    rad_lst = rad_lst[length(rad_lst)]
    print (paste0(donor, ": NO TCs in the range [150 NM, max_rad]...although there can be >=3 TC within 150NM!"))
  }
  
  #print (rad_lst)
  
  # Start writing the rows, 'donor_rad'
  for (rad in rad_lst) {    # In miles
    var_name = paste(donor, rad, sep = "_")
    # print (var_name)
    
    # Receiving TCs of this donor at circle radius 'rad':
    recv_TCs = temp[temp[, 1] < rad, 2]
    df_rad[k, ] = NA
    df_rad[k, 1] = var_name
    sup = df_sup[as.character(df_sup[, 1]) == donor, ncol(df_sup)]
    to_dem = df_dem[df_dem[, 1] %in% recv_TCs, "dem"]  # Vector of demands
    for (j in recv_TCs) {
      df_rad[k, j] = df_dem[df_dem[, 1] == j, "dem"] / sum(to_dem) * sup
    }
    k = k + 1
  }
}

Sys.time()
# 40 mins for 4 dgt, 600 NM
```

```{r}
# df_rad = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/ZIP_models/ub_d_500/Alaska/df_rad_4dgt_500NM_alaska.csv"); df_rad = df_rad[, -1]
# as.numeric(str_split(df_rad$donor_rad[2], "_")[[1]][3])
# max(as.numeric(sapply(c(1:nrow(df_rad)), function(i) {str_split(df_rad$donor_rad[i], "_")[[1]][3]}))) / (1.609 * 1.15078)
```

# Sensitivity analysis: Skips some years in calculating s/d ratio:
```{r}
fil = "result_4dgt_circles_450NM_beta_1_alph_0_lam_0.54_min_dst_150NM_min_TC_3_alaska_gap 0.1679%"
df_sol = read.csv(paste0("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/ZIP_models/ub_d_450//", fil, ".csv"))
df_sol = df_sol[df_sol$result.x == 1, ]
df_sol$variables = as.character(df_sol$variables)
if (zip_cluster == 4) {
  df_sol$don = substring(df_sol$variables, first = 3, last = 8)
  df_sol$rad = as.numeric(substring(df_sol$variables, first = 10))
}

## Skipping ONE year at a time:

for (skip_yr in c(0:4)) {
  df_dem$dem = df_dem[, c("MELD.15_2013")] * ifelse(skip_yr == 1, 0, 1) + df_dem[, c("MELD.15_2014")] * ifelse(skip_yr == 2, 0, 1) + 
               df_dem[, c("MELD.15_2015")] * ifelse(skip_yr == 3, 0, 1) + df_dem[, c("MELD.15_2016")] * ifelse(skip_yr == 4, 0, 1)
  df_sup$sup = df_sup[, c("donor_2013")] * ifelse(skip_yr == 1, 0, 1) + df_sup[, c("donor_2014")] * ifelse(skip_yr == 2, 0, 1) + 
               df_sup[, c("donor_2015")] * ifelse(skip_yr == 3, 0, 1) + df_sup[, c("donor_2016")] * ifelse(skip_yr == 4, 0, 1)
  
  df_rad_x = data.frame(matrix(ncol = nrow(df_dem) + 1))
  colnames(df_rad_x) = c('donor_rad', df_dem[, 1])
  
  min_rad = 150 # In nautical miles
  
  max_rad_ = max_rad
  k = 1     # Denotes row number in df_rad_x
  for (donor in df_sup$zip_cluster) {
  
    temp = as.data.frame(t(df_donor_trnspl_dist[as.character(df_donor_trnspl_dist[, 1]) == as.character(donor), ])[-1, ])
    temp[, 1] = as.numeric(as.character(temp[, 1]))
    temp[, 2] = row.names(temp)
   
    temp = temp[temp[, 1] <= max_rad_ * 1.609 * 1.15078, ]   # Centers <= max_rad_
    
    rad = df_sol[df_sol$don == as.character(donor), "rad"]
    var_name = paste(donor, rad, sep = "_")
  
    # Receiving TCs of this donor at circle radius 'rad':
    recv_TCs = temp[temp[, 1] < rad, 2]
    df_rad_x[k, ] = NA
    df_rad_x[k, 1] = var_name
    sup = df_sup[as.character(df_sup[, 1]) == donor, "sup"]
    to_dem = df_dem[df_dem[, 1] %in% recv_TCs, "dem"]  # Vector of demands
    for (j in recv_TCs) {
      df_rad_x[k, j] = df_dem[df_dem[, 1] == j, "dem"] / sum(to_dem) * sup
    }
    k = k + 1
  }
  
  discarded_donors_supply = 0
  # Specify demand column: NOTE: LAST Column is the demand column
  dem_col = df_dem[, "dem"]
  
  # Specify supply column: NOTE: LAST Column is the supply column
  sup_col = df_sup[, "sup"]
  
  donor_clstrs = df_sup[, 1]
  transplant_centres = (df_dem[, 1])
  
  neighbours_cnt = c()
  lambda = c()
  max_dist = c()
  
  for (j in transplant_centres) {
    temp = df_rad_x[!is.na(df_rad_x[, j]), c("donor_rad", j)]
    neighbours_cnt = c(neighbours_cnt, nrow(temp))
    dem_j = df_dem[df_dem[, 1] == j, "dem"]
    supply_j = sum(temp[, 2]) + dem_j / sum(dem_col) * discarded_donors_supply
    lambda = c(lambda, supply_j / dem_j)
    # lambda = c(lambda, sum(temp[, 2]) / df_dem[df_dem[, 1] == j, "dem"])
    temp[, 1] = as.character(temp[, 1])
    rad_lst = as.numeric(sapply(strsplit(temp[, 1], "_"), tail, 1)) / (1.609 * 1.15078)
    max_dist = c(max_dist, max(rad_lst))
  }
  
  if (skip_yr == 0) {
    lambdas = data.frame(skip_yr, transplant_centres, neighbours_cnt, max_dist, lambda)
  } else {
    lambdas = rbind(lambdas, data.frame(skip_yr, transplant_centres, neighbours_cnt, max_dist, lambda))
  }
}

temp = data.table(lambdas)[, list(min_sd_ratio = min(lambda, na.rm = T), max_sd_ratio = max(lambda, na.rm = T)), by = list(skip_yr)]
```



```{r}

dist_matrix_txc = read.csv('Files_JHU/Shubham_downloads/dist_matrix_txc.csv')
```

# Function to create 'constraint matix':
```{r}
df_T = function(min_lam, beta_stage, max_beta, alpha_stage, max_alpha, order, eval_dist) {
    df = data.frame(variable = c())
  
  donor_clstrs = as.character(df_sup[, 1]) #[1:4] 
  transplant_centres = as.character(df_dem[, 1]) #[1:4]
  
  #min_dist_donor = data.frame(donor = as.character(df_donor_trnspl_dist[, 1]), nearest_TC_dist = sapply(c(1:nrow(df_donor_trnspl_dist)), function(x) {min(df_donor_trnspl_dist[x, -1]) / (1.609 * 1.15078)}))    # In nautical miles
  
  # Enter variables:
  df[1, 1] = paste('lambda')
  row =  nrow(df) + 1
  for (i in df_rad$donor_rad) {
    df[row, 1] = paste("x", i, sep = "_")
    row =  nrow(df) + 1
  }
  
  # Beta row:
  row =  nrow(df) + 1
  if (beta_stage == 1) {
    df[row, 1] = paste('beta')
    row =  nrow(df) + 1
  }
  
  # Apha row:
  row =  nrow(df) + 1
  if (alpha_stage == 1) {
    df[row, 1] = paste('alpha')
    row =  nrow(df) + 1
  }
  
  # Assign a row as rhs_sense:
  df[row, 1] = 'rhs_sense'
  rhs_sense = row
  row = row + 1
  
  # Assign last row as RHS row:
  df[row, 1] = 'RHS'
  rhs = row
  
  # Write Objective function:
  if ((alpha_stage == 0) & (beta_stage == 0)) {
    row = which(df[, 1] == paste("lambda"))
    df[row, 2] = 1
  } else if ((alpha_stage == 1) & (beta_stage == 0)) {
    row = which(df[, 1] == paste("alpha"))
    df[row, 2] = 1
  } else if ((alpha_stage == 0) & (beta_stage == 1)) {
    row = which(df[, 1] == paste("beta"))
    df[row, 2] = 1
  } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "alpha_beta")) {
    row = which(df[, 1] == paste("beta"))
    df[row, 2] = 1
  } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "beta_alpha")) {
    row = which(df[, 1] == paste("alpha"))
    df[row, 2] = 1
  } 
  
  # Write constraints:
  
  # Constraint 1: Assign only one 'radius' to a donor:
  col = ncol(df) + 1
  for (donor in donor_clstrs) {
    #row = which(df[, 1] == paste('x', i, sep = "_"))
    df[grep(donor, df[, 1]), col] = 1
    df[rhs_sense, col] = "="
    df[rhs, col] = 1
    col = col + 1
  }

    # Constraint 2: s/d ratios at transplant centers...lambdas:
  col = ncol(df) + 1
  for (j in transplant_centres) {
    dj = df_dem[df_dem$transplant_center == j, c("dem")]
    
    # List variables that are associated with postive organ supply to this Center:
    j_lst = df_rad[!is.na(df_rad[, j]), 1] 
    
    for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"
      # donor = substr(var, start = 3, stop = ifelse(zip_cluster_dgt == "2", 4, 5))   # THERE IS A BIG ISSUE WITH THIS!!!!, WAHT ABOUT 4_dgt ZIP CLUSTER??
      var =  as.character(var)
      rad = as.numeric(strsplit(var, "_")[[1]][3])    # In miles
      
      row = which(df[, 1] == paste('x', var, sep = "_"))
      df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific radius
    }
    row_lam = which(df[, 1] == paste("lambda"))
    df[row_lam, col] = -1   # Corresponds to 'lambda'
    df[rhs_sense, col] = ">="
    df[rhs, col] = 0
    col = col + 1
  }
  
  # Constraint 3: s/d ratios at transplant center for BETA stage:
  if (beta_stage == 1) { ##| (stage3 == 1)) {
  
  col = ncol(df) + 1
  for (j in transplant_centres) {
    dj = df_dem[df_dem$transplant_center == j, c("dem")]
    
    # List variables that are associated with postive organ supply to this Center:
    j_lst = df_rad[!is.na(df_rad[, j]), 1] 
    
    for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"
      #donor = substr(var, start = 3, stop = ifelse(zip_cluster == "2", 4, 5))   # THERE IS A BIG ISSUE WITH THIS!!!!, WAHT ABOUT 4_dgt ZIP CLUSTER??
      rad = as.numeric(strsplit(var, "_")[[1]][3])    # In miles
      
      row = which(df[, 1] == paste('x', var, sep = "_"))
      df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific radius
      }
    df[which(df[, 1] == "beta"), col] = -1   # Corresponds to 'beta'
    df[rhs_sense, col] = "<="
    df[rhs, col] = 0
    col = col + 1
    }
  }

  if (alpha_stage == 1) print (paste("TCs_in_Stage3:", TCs_in_Stage3))
  return (t(df))
}
```

```{r}
sum(df_dem$dem)
```

```{r}
# 2 hrs for beta stage 700NM, 4 dgt!
Sys.time()
zip_cluster_dgt = zip_cluster
min_lam = NA; beta_stage = 1
# #min_lam = 0.51; beta_stage = 1
# max_beta = 0.61
alpha_stage = 0 
# max_alpha = 0.002
# order = "beta_alpha"
# #order = "alpha_beta"
# eval_dist = 150
df = as.data.frame(df_T(min_lam, beta_stage, max_beta, alpha_stage, max_alpha, order, eval_dist))
Sys.time()

#df_src = df
write.csv(df, "/Users/sakshat/Desktop/df_500_hierobj.csv", row.names = F)
```

```{r eval=FALSE, include=FALSE}
Sys.time()
model = list()
A = as.matrix(df[3:nrow(df), 1:(ncol(df) - 2)])
A = data.frame(sapply(data.frame(A), function(x) as.numeric(as.character(x))))
A[is.na(A) ] = 0
A = as.matrix(A)
model$A = as(A, "sparseMatrix")

# 
# temp = as(A, "sparseMatrix") 
# writeMM(temp,file=paste0("A_", zip_cluster, "_", max_rad, "NM.txt"))
# # readMM(file='test.txt')
# df[1, 1]
#

variables = head(as.character(unlist(df[1, ])), -2) # print (variables)
model$sense = as.character(unlist(df[3:nrow(df), (ncol(df)-1)])) # print (sense)
model$rhs = as.numeric(as.character(df[3:nrow(df), ncol(df)]))

##
# model$obj = head(as.numeric(as.character(unlist(df[2,]))), -2) # as.numeric(df[c(1:(nrow(df)-2)), 2])
# model$obj[is.na(model$obj)] = 0

# Hierarchical multi-objective:
model$multiobj = list()
model$multiobj[[1]] = list()
model$multiobj[[1]]$objn = -1 * c(1, rep(0, ncol(df)-3))   # -1 because modelsense is "min"
model$multiobj[[1]]$priority = 1

model$multiobj[[2]] = list()
model$multiobj[[2]]$objn = c(rep(0, ncol(df)-3), 1)
model$multiobj[[2]]$priority = 0
##
model$vtype = c('C', rep('B', length(grep('x_', as.character(unlist(df[1, ]))))))
#model$vtype = c('C', rep('B', 54175))

if ((alpha_stage == 0) & (beta_stage == 0)) {
    model$modelsense = "max"
  } else if ((alpha_stage == 1) & (beta_stage == 0)) {
    model$vtype = c(model$vtype, "C")
    model$modelsense = "min"
  } else if ((alpha_stage == 0) & (beta_stage == 1)) {
    model$vtype = c(model$vtype, "C")
    model$modelsense = "min"
  } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "alpha_beta")) {
    model$vtype = c(model$vtype, "C", "C")
    model$modelsense = "min"
  } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "beta_alpha")) {
    model$vtype = c(model$vtype, "C", "C")
    model$modelsense = "min"
  } 
Sys.time()
# df[1, 54177:54179]
```



```{r}
Sys.time()

mip_gap = 0.0003
params = list(MIPFocus = 0, TimeLimit = 3600 * 24,
                    FeasibilityTol = 1e-6, IntFeasTol = 1e-9, MIPGap = mip_gap, OptimalityTol = 1e-6,
                    ObjScale = -0.5, ScaleFlag = 0, Heuristics = 0.05, Cuts = -1,
                    Presolve = 2, PreSparsify = 0, NumericFocus = 1, Aggregate = 0)

result = gurobi(model, params)
Sys.time()
```

```{r}
if (fixed_rad == 1) {
  write.csv(data.frame(variables, result$x), paste0("result_fixed_rad_", zip_cluster_dgt, "_dgt_" , max_rad_, "_alaska.csv"), row.names = F)
}
```

```{r}
#write.csv(df, paste0("A_", zip_cluster, "dgt_circles_", max_rad, "nmi_", "beta_", beta_stage, "_lam_", min_lam, ".csv"), row.names=F)
# write.csv(data.frame(variables, result$x), paste0("result_", zip_cluster, "dgt_circles_", max_rad, "nmi_", "beta_", beta_stage, "_lam_", min_lam, "min_dist_", min_rad, "nmi_min_TC_", "3_MIP0.8per_stage3_2hrs.csv"), row.names = F)

if (fixed_rad == 0) {
  min_rad = 150
  
  fil_name = paste0(zip_cluster, "dgt_circles_", max_rad, "NM_", "beta_", beta_stage, "_alph_", alpha_stage, "_lam_", min_lam, "_min_dst_", min_rad, "NM_min_TC_3_", "eval_", eval_dist)
  
  if ((alpha_stage == 0) & (beta_stage == 0)) {
    fil_name = paste0(zip_cluster, "dgt_", max_rad, "NM_", "beta_", beta_stage, "_alph_", alpha_stage, "_min_dst_", min_rad, "NM_min_TC_3")
    } else if ((alpha_stage == 1) & (beta_stage == 0)) {
      fil_name = paste0(zip_cluster, "dgt_circles_", max_rad, "NM_", "beta_", beta_stage, "_alph_", alpha_stage, "_lam_", min_lam, "_min_dst_", min_rad, "NM_min_TC_3_", "eval_", eval_dist)
    } else if ((alpha_stage == 0) & (beta_stage == 1)) {
      fil_name = paste0(zip_cluster, "dgt_circles_", max_rad, "NM_", "beta_", beta_stage, "_alph_", alpha_stage, "_lam_", min_lam, "_min_dst_", min_rad, "NM_min_TC_3")
    } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "alpha_beta")) {
      fil_name = paste0(zip_cluster, "dgt_circles_", max_rad, "NM_", "alph_", alpha_stage, "_beta_", beta_stage, "_lam_", min_lam, "_min_dst_", min_rad, "NM_min_TC_3_", "eval_", eval_dist)
    } else if ((alpha_stage == 1) & (beta_stage == 1) & (order == "beta_alpha")) {
      fil_name = paste0(zip_cluster, "dgt_circles_", max_rad, "NM_", "beta_", beta_stage, "_alph_", alpha_stage, "_lam_", min_lam, "_min_dst_", min_rad, "NM_min_TC_3_", "eval_", eval_dist)
    } 
  
   write.csv(data.frame(variables, result$x, model$obj), paste0("result_", fil_name, "_alaska.csv"), row.names = F)
}
```


```{r}
fetch_val = function(cluster1, cluster2_or_transplant_centre, df1) {   # Assuming symmetric values
  row_cluster1 = which(df1[, 1] == cluster1)
  val = df1[row_cluster1, cluster2_or_transplant_centre]
  return (as.numeric(val))
}
```


```{r}
discarded_donors_supply=0
cal_lambdas = function(result_df_name) {
  
  result_df = read.csv(result_df_name)
  result_df[, 1] = as.character(result_df[, 1])
  # Specify demand column: NOTE: LAST Column is the demand column
  dem_col = df_dem[, ncol(df_dem)]
  
  # Specify supply column: NOTE: LAST Column is the supply column
  sup_col = df_sup[, ncol(df_sup)]
  
  donor_clstrs = df_sup[, 1]
  transplant_centres = (df_dem[, 1])
  
  neighbours_cnt = c()
  lambda = c()
  max_dist = c()
  
  result_df = result_df[(grep('x_', result_df[, 1]) ), ]
  result_df = result_df[result_df[, 2]==1, ]
  don_rad = substring(result_df[, 1], 3)    # Removing first 2 characters: "x_"
  
  df_rad_x = df_rad[df_rad[, 1] %in% don_rad, ]
  
  for (j in transplant_centres) {
    temp = df_rad_x[!is.na(df_rad_x[, j]), c("donor_rad", j)]
    neighbours_cnt = c(neighbours_cnt, nrow(temp))
    dem_j = df_dem[df_dem[, 1] == j, "dem"]
    supply_j = sum(temp[, 2]) + dem_j / sum(dem_col) * discarded_donors_supply
    lambda = c(lambda, supply_j / dem_j)
    # lambda = c(lambda, sum(temp[, 2]) / df_dem[df_dem[, 1] == j, "dem"])
    temp[, 1] = as.character(temp[, 1])
    rad_lst = as.numeric(sapply(strsplit(temp[, 1], "_"), tail, 1)) / (1.609 * 1.15078)
    max_dist = c(max_dist, max(rad_lst))
  }
  
  return (data.frame(transplant_centres, neighbours_cnt, max_dist, lambda))
}
```


```{r}
discarded_donors_supply=0
if (fixed_rad == 1) {
  temp = paste0("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation//", "result_fixed_rad_", zip_cluster_dgt, "_dgt_" , max_rad_, "_alaska.csv")
  lambdas = cal_lambdas(result_df_name = temp)
}
```

```{r}
variables = head(as.character(unlist(df[1, ])), -2) # print (variables)
variables = c("lambda", df_rad[, 1], "beta")
as.character(unlist(df[1, ]))
length(variables)
df[1, 113]
variables[113]
```


```{r}
file_name = "/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/"
discarded_donors_supply=0

fil_name = "result_3dgt_circles_350NM_beta_1_alph_0_lam_0.51_min_dst_150NM_min_TC_3_alaska"

#lambdas = cal_lambdas(result_df_name = paste0("result_", fil_name, ".csv", sep = ""))
lambdas = cal_lambdas(result_df_name = paste0(file_name, fil_name, ".csv", sep = ""))
#lambdas = cal_lambdas(result_df_name = paste0("result_", fil_name, ".csv", sep = ""))

# ggplot(lambdas, aes(x = transplant_centres, y = lambda)) +
  geom_point()

#write.csv(lambdas, paste("lam_", paste(file_name, ".csv", sep = ""), sep = ""), row.names = F)
```


```{r}
# Calculate "Supply to Demand" ratios near a Transplant Center, say within 100, 150 NAUTICAL miles

dist_matrix_txc = read.csv('Files_JHU/Shubham_downloads/dist_matrix_txc.csv')
#tx_ub_d = data.frame(dist_matrix_txc[, 1], cnt_t_centres = NA)
#tx_ub_d$cnt_t_centres = sapply(c(1:nrow(dist_matrix_txc)), function(x) {sum(dist_matrix_txc[x, -c(1, (x+1))] < ub_d_tx)})  # (x+1) so as no to count self!

# lambdas = read.csv('circles_ratio_300.csv')

for (y in c(100, 150)) {
  ub_d_tx = y * 1.609 * 1.15078
  
  lambdas[, paste("tx_cnt", paste0(y, "NM"), sep = "_")] = NA
  lambdas[, paste("max_ratio", paste0(y, "NM"), sep = "_")] = NA
  
  for (tx in lambdas[, 1]) {
    row = which(lambdas[, 1] == tx)
    tx_within_ub_d_tx = as.character(dist_matrix_txc[which(dist_matrix_txc[, tx] < ub_d_tx), 1])
    temp = lambdas[lambdas$transplant_centres %in% tx_within_ub_d_tx, ]   
    # temp = lambdas[lambdas$tx_ctr_cd %in% tx_within_ub_d_tx, ]  
    lambdas[row, ncol(lambdas)-1] = nrow(temp)
    lambdas[row, ncol(lambdas)] = max(temp$lambda)
    # lambdas[row, ncol(lambdas)] = max(temp$ratio_15)
  }
  lambdas[, paste("ratio_diff", paste0(y, "NM"), sep = "_")] = NA
  lambdas[, ncol(lambdas)] = lambdas[, ncol(lambdas)-1] - lambdas[, c("lambda")]
  # lambdas[, ncol(lambdas)] = lambdas[, ncol(lambdas)-1] - lambdas[, c("ratio_15")]
}

if (fixed_rad == 1) {
  write.csv(lambdas, paste0("lam_", "fixed_rad_", zip_cluster_dgt, "_dgt_" , max_rad_, "_alaska.csv"), row.names = F)
} else {
  fil_n = fil_name#strsplit(file_name, "/")[[1]][2]
  write.csv(lambdas, paste("lam_", paste0(fil_n, ".csv", sep = ""), sep = ""), row.names = F)
}
```

# TO calculate summary statistics of radius around donor zip clusters:
```{r}
fil = "result_4dgt_circles_700NM_beta_1_alph_0_lam_0.55_min_dst_150NM_min_TC_3_alaska_gap gap 0.0982%"
df = read.csv(paste0("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/ZIP_models/ub_d_700/Alaska/", fil, ".csv"))
df = df[df$result.x == 1, ]
df$variables = as.character(df$variables)
lst = sapply(df$variables, function(x) {as.numeric(strsplit(x, "_")[[1]][4])/(1.609 * 1.15078)})
summary(lst)
```


```{r}
```


```{r}
```

